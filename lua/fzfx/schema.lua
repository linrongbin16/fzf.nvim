-- ======== Provider ========
-- Provider defines the FZF_DEFAULT_COMMAND, which can generate the list for fzf.
-- E.g. grep(rg), find(fd).
--
-- Here we define 3 types of providers:
--  * Command provider: a lua function to run and generate a shell command, execute it and generate the list.
--  * List provider: a lua function to run and directly generate the list.
--
--- @alias CommandProvider fun(query:string?):string
--- @alias ListProvider fun(query:string?):string[]
--- @alias Provider CommandProvider|ListProvider

-- ======== LineProcessor ========
-- Processor defines how to process each line generated by provider, and finally print to fzf.
-- E.g. add the icons for each file.
--
--- @alias LineProcessor fun(line:string):string

-- ======== Previewer ========
-- Previewer defines how to preview the list item in fzf.
-- E.g. cat(bat).
--
-- Here we define 2 types of previewers:
--  * Command previewer: a lua function to run and generate a shell command, execute it and generate the preview prints.
--  * Nvim buffer previewer: a lua function to run and generate a nvim buffer (todo).
--    (I think the most powerful feature on builtin nvim-buffer previewer is maybe allow users navigate from fzf input prompt to the previewer buffer and directly edit the buffer, but I didn't do any investigation so I'm not sure).
--
--- @alias CommandPreviewer fun(...:any):string
--- @alias Previewer CommandPreviewer

-- ======== InteractiveKey ========
-- InteractiveKey defines how to interact with fzf
--
--- @alias InteractiveKey string
--- @alias InteractiveKeyHelpFormat string?

-- ======== ExpectKey ========
-- ExpectKey defines how to exit fzf and execute callbacks on the selected lines.
--
--- @alias ExpectKey string

-- ======== Action ========
-- Action defines the callbacks to execute on selected lines.
--
--- @alias Action fun(lines:string[]?):nil

-- ======== User Command Option Attribute ========
-- See: https://neovim.io/doc/user/api.html#nvim_create_user_command()
--
--- @alias UserCommandAttributeKey "bang"|"nargs"|"complete"|"range"|"desc"
--- @alias UserCommandAttributeValue boolean|string

-- ======== Feed Method ========
-- Feed method defines what query to feed the command.
-- E.g. command args, visual select, cursor word, yank text.
--
--- @alias FeedMethod "args"|"visual"|"cword"|"yank"

-- ======== Fzf Option ========
-- Fzf option defines extra options to pass to the fzf command.
-- E.g. --multi, --bind=ctrl-e:toggle
--
--- @alias SimpleFzfOpt string|string[]
--- @alias FunctionalFzfOpt fun():SimpleFzfOpt
--- @alias FzfOpt SimpleFzfOpt|FunctionalFzfOpt
--- @alias FzfOpts FzfOpt[]

--- @class Pipeline
--- @field provider Provider?
--- @field line_processor LineProcessor?
--- @field previewer Previewer?
--- @field help_format InteractiveKeyHelpFormat?
local Pipeline = {
    provider = nil,
    line_processor = nil,
    previewer = nil,
    help_format = nil,
}

function Pipeline:make(opts)
    return vim.tbl_deep_extend("force", vim.deepcopy(Pipeline), opts or {})
end

-- ======== Schema ========
-- Schema defines how to generate a fzfx command in this plugin.
-- It can have multiple providers, you can press the interactive key to switch to the binded provider.
-- It can have multiple previewers, you can press the interactive key to switch to the binded previewer.
-- It has a default provider and previewer.
-- It can have multiple expect keys, you can press expect keys to exit fzf and execute callbacks on selections.
-- It needs some user command options to create the user command, e.g. FzfxFiles(U).
-- It needs defines how to feed the query to the user command, e.g. by visual select, cursor word.
-- It needs defines extra fzf options to pass to the fzf command (if any), e.g. --multi --bind=ctrl-e:toggle.
--
-- Note: The providers and previewers must match, when there's only 1 provider and previewer, the interactive key will be omitted.
--
--- @class Schema
--- @field name string?
--- @field pipelines table<InteractiveKey, Pipeline>?
--- @field default_pipeline Pipeline?
--- @field interactive_actions table<InteractiveKey, Action>?
--- @field expect_actions table<ExpectKey, Action>?
--- @field command_opts table<UserCommandAttributeKey, UserCommandAttributeValue>?
--- @field feed_method FeedMethod?
--- @field fzf_opts FzfOpts?
local Schema = {
    name = nil,
    pipelines = nil,
    default_pipeline = nil,
    interactive_actions = nil,
    expect_actions = nil,
    command_opts = nil,
    feed_method = nil,
    fzf_opts = nil,
}

function Schema:make(opts)
    return vim.tbl_deep_extend("force", vim.deepcopy(Schema), opts or {})
end

--- @class NormalCommandOpts
local NormalCommandOpts = {
    bang = true,
    nargs = "?",
}

function NormalCommandOpts:make(opts)
    return vim.tbl_deep_extend(
        "force",
        vim.deepcopy(NormalCommandOpts),
        opts or {}
    )
end

--- @class VisualCommandOpts
local VisualCommandOpts = {
    bang = true,
    range = true,
}

function VisualCommandOpts:make(opts)
    return vim.tbl_deep_extend(
        "force",
        vim.deepcopy(VisualCommandOpts),
        opts or {}
    )
end

--- @class CwordCommandOpts
local CwordCommandOpts = {
    bang = true,
}

function CwordCommandOpts:make(opts)
    return vim.tbl_deep_extend(
        "force",
        vim.deepcopy(CwordCommandOpts),
        opts or {}
    )
end

--- @class PutCommandOpts
local PutCommandOpts = {
    bang = true,
}

function PutCommandOpts:make(opts)
    return vim.tbl_deep_extend(
        "force",
        vim.deepcopy(PutCommandOpts),
        opts or {}
    )
end

local M = {
    Pipeline = Pipeline,
    Schema = Schema,
    NormalCommandOpts = NormalCommandOpts,
    VisualCommandOpts = VisualCommandOpts,
    CwordCommandOpts = CwordCommandOpts,
    PutCommandOpts = PutCommandOpts,
}

return M
